import fs from 'node:fs';
import path from 'node:path';

const MICRO = JSON.parse(fs.readFileSync('content/microcopy.json', 'utf8'));
const ROOTS = ['app', 'components', 'pages']; // add more dirs here
const EXTS = new Set(['.tsx', '.ts', '.jsx', '.js']);
const OUT_JSON = 'reports/copy-coverage.json';
const OUT_MD = 'reports/copy-coverage.md';

// flatten microcopy to a reverse lookup: text -> keyPath
const flat = {};
for (const [group, obj] of Object.entries(MICRO)) {
  for (const [key, val] of Object.entries(obj)) {
    if (typeof val === 'string') flat[val] = `${group}.${key}`;
  }
}

const items = []; // { text, file, line, matchKey?:string, type:"wired"|"raw" }
function walk(dir) {
  for (const f of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, f.name);
    if (f.isDirectory()) walk(p);
    else if (EXTS.has(path.extname(f.name))) scan(p);
  }
}
function add(text, file, line, matchKey, type) {
  const t = text.trim();
  if (!t) return;
  if (/^https?:\/\//i.test(t)) return;
  if (t.length < 3) return;
  if (/^[\s\d.,:;!?'"(){}[\]-]+$/.test(t)) return; // punctuation only
  if (t.toLowerCase().includes('copyright')) return;
  items.push({ text: t, file, line, matchKey, type });
}
function scan(file) {
  const src = fs.readFileSync(file, 'utf8');
  const lines = src.split(/\r?\n/);

  lines.forEach((ln, i) => {
    // 1) find t("group","key") usages (wired)
    ln.replace(/t\(\s*["']([\w-]+)["']\s*,\s*["']([\w-]+)["']\s*\)/g, (_, g, k) => {
      add(`${g}.${k}`, file, i + 1, `${g}.${k}`, 'wired');
      return _;
    });

    // 2) capture likely UI strings in JSX text nodes > text <
    ln.replace(/>([^<>]{1,200})</g, (_, m) => {
      const txt = m.trim();
      if (!txt) return _;
      const matchKey = flat[txt];
      add(txt, file, i + 1, matchKey, matchKey ? 'wiredText' : 'raw');
      return _;
    });

    // 3) capture prop strings for placeholders, labels, titles, aria, alt
    ln.replace(
      /\b(placeholder|alt|aria-label|title)\s*=\s*["'`]([^"'`]{1,200})["'`]/g,
      (_, prop, val) => {
        const txt = val.trim();
        const matchKey = flat[txt];
        add(txt, file, i + 1, matchKey, matchKey ? 'wiredProp' : 'raw');
        return _;
      },
    );
  });
}

for (const r of ROOTS) if (fs.existsSync(r)) walk(r);

// summarize
const wired = items.filter(
  (i) => i.type === 'wired' || i.type === 'wiredText' || i.type === 'wiredProp',
);
const raw = items.filter((i) => i.type === 'raw');

// de-duplicate raw by text+file+line for a readable report
const uniqRaw = [];
const seen = new Set();
for (const r of raw) {
  const k = `${r.text}|${r.file}|${r.line}`;
  if (!seen.has(k)) {
    seen.add(k);
    uniqRaw.push(r);
  }
}

// write JSON
fs.mkdirSync('reports', { recursive: true });
fs.writeFileSync(
  OUT_JSON,
  JSON.stringify(
    { totals: { wired: wired.length, raw: uniqRaw.length }, wired, raw: uniqRaw },
    null,
    2,
  ),
);

// write MD checklist
const toMD = (arr) =>
  arr.map((r) => `- [ ] \`${r.text}\`  \n  â†³ **${r.file}:${r.line}**`).join('\n');
const md = `# Copy Coverage

**Totals**  
- Wired via \`t()\`: ${wired.length}  
- Raw/hardcoded: ${uniqRaw.length}

## Raw (wire these to \`/content/microcopy.json\`)
${uniqRaw.length ? toMD(uniqRaw) : '-  None! All covered.'}

---
*Generated by scripts/copy-coverage.mjs*
`;
fs.writeFileSync(OUT_MD, md);

console.log(` Copy coverage -> ${OUT_JSON} & ${OUT_MD}`);
const MAX_RAW = parseInt(process.env.COPY_MAX_RAW || '9999', 10); // set lower in CI once clean
if (uniqRaw.length > MAX_RAW) {
  console.error(` Too many raw strings: ${uniqRaw.length} (limit ${MAX_RAW})`);
  process.exit(1);
}
